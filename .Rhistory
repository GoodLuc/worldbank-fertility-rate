rm(list = ls())
#Cargo Librerias
library(ggplot2)
library(ggrepel)
library(plotly)
library(lubridate)
library(htmlwidgets)
library(RColorBrewer)
library(sqldf)
library(data.table)
library(readr)
library(dplyr)
library(patchwork)
install.packages("tcltk")
install.packages("RSQLite")
rm(list = ls())
#Cargo Librerias
library(ggplot2)
library(ggrepel)
library(plotly)
library(lubridate)
library(htmlwidgets)
library(RColorBrewer)
library(sqldf)
library(data.table)
library(readr)
library(dplyr)
library(patchwork)
install.packages("patchwork")
library(patchwork)
datos <- read_delim("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", ",", escape_double = FALSE, col_types = cols(codigo = col_integer()),
locale = locale(grouping_mark = ""),
trim_ws = TRUE)
datos <- read.csv("mydata.csv", skip = 3, header = TRUE)
#Cargo el dataset API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv
datos <- read.csv("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", skip = 3, header = TRUE)
# Visualizo la tabla que se subio
View(datos)
colnames(datos)  #Visualizo las columnas que se crearon
# Creo un data frame sobre los datos para eliminar ciertas columnas con metadatos innecesarios para mi gráfico,
# usando la función "subset"
datos <- data.frame(x = 1:1, y = 2:4, z = 5:ncol(datos))
datos <- subset(datos, select = -y)
# Cargo el dataset API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv
datos <- read.csv("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", skip = 3, header = TRUE)
# Eliminar ciertas columnas con metadatos innecesarios para mi gráfico usando la función "subset"
datos <- subset(datos, select = -2:4)
# Eliminar ciertas columnas con metadatos innecesarios para mi gráfico usando la función "subset"
datos <- subset(datos, select = -c(2:4))
# Elimino países que no tienen datos para ningun año
datos <- datos[complete.cases(datos[, 2:ncol(datos)]), ]
# Cargo el dataset API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv. Evito las primeras 3 filas que poseen metadatos innecesarios.
datos_raw <- read.csv("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", skip = 3, header = TRUE)
# Eliminar ciertas columnas con más metadatos innecesarios para mi gráfico, usando la función "subset."
datos_clean <- subset(datos, select = -c(2:4))
# Cargo el dataset API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv. Evito las primeras 3 filas que poseen metadatos innecesarios.
datos_raw <- read.csv("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", skip = 3, header = TRUE)
# Eliminar ciertas columnas con más metadatos innecesarios para mi gráfico, usando la función "subset."
datos_clean <- subset(datos_raw, select = -c(2:4))
# Elimino países que no tienen datos para ningun año
datos_clean2 <- datos_clean[apply(datos_clean[,-1], 1, function(x) any(!is.na(x))),]
View(datos_clean)
View(datos_clean2)
colnames(datos)  #Visualizo las columnas que se crearon
# Visualizo la tabla
View(datos_clean2)
# Elimino países que no tienen datos para ningun año
datos_ready <- datos_clean[apply(datos_clean[,-1], 1, function(x) any(!is.na(x))),]
# Visualizo las columnas que se crearon
colnames(datos_ready)
#Reviso como estan cargadas las variables
class(datos_ready$`Country.Name ($)`)
class(datos_ready)
# Reviso como estan cargadas las variables
class(datos_ready$`X1960 ($)`)
column_classes <- sapply(data, class)
print(column_classes)
# Reviso como estan cargadas las variables
class(datos_ready$X1960)
column_classes <- sapply(datos_ready, class)
print(column_classes)
View(datos_ready)
install.packages("ggplot2")
install.packages("reshape2")
install.packages("ggplot2")
library(ggplot2)
library(reshape2)
# Cargo el dataset API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv. Evito las primeras 3 filas que poseen metadatos innecesarios.
datos_raw <- read.csv("API_SP.DYN.TFRT.IN_DS2_en_csv_v2_5358686.csv", skip = 3, header = TRUE)
# Eliminar ciertas columnas con más metadatos innecesarios para mi gráfico, usando la función "subset."
datos_clean <- subset(datos_raw, select = -c(2:4))
# También elimino columnas que no poseen datos
datos_clean <- datos_clean[, !apply(is.na(datos_clean), 2, all)]
# Elimino países que no tienen datos para ningun año
datos_ready <- datos_clean[apply(datos_clean[,-1], 1, function(x) any(!is.na(x))),]
# Visualizo el data frame
View(datos_ready)
# Reviso y confirmo las clases de las columnas del data frame.
class(datos_ready)
column_classes <- sapply(datos_ready, class)
print(column_classes) # Algunos
# Reformateamos el data frame a formato "long" usando melt para que sea compatible con las funciones de ploteo de ggplot2
# Esto nos servira para general nuestro gráfico estilo "heatmap."
long_data <- melt(datos_ready, id.vars = "Country.Name", variable.name = "Year", value.name = "Value")
View(long_data)
# Convertimos las variables de año a tipo de dato "factor", para que aparezcan ordenados correctamente en el eje x.
long_data$Year <- factor(long_data$Year, levels = unique(long_data$Year))
View(long_data)
# Reformateamos el data frame a formato "long" usando melt para que sea compatible con las funciones de ploteo de ggplot2
# Esto nos servira para general nuestro gráfico estilo "heatmap."
long_data <- melt(datos_ready, id.vars = "Country.Name", variable.name = "Year", value.name = "Value")
# En esta etapa voy a renombrar los nombres de las columnas principales al español
colnames(long_data)[colnames(long_data) == "Country.Name"] <- "País"
colnames(long_data)[colnames(long_data) == "Year"] <- "Año"
heatmap <- ggplot(long_data, aes(x = Año, y = País, fill = Value)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "red", mid = "orange", high = "yellow", midpoint = median(long_data$Value), guide = "colorbar") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
xlab("Año") +
ylab("País")
# Display the heatmap
print(heatmap)
install.packages("countrycode")
library(countrycode)
View(datos_ready)
# Primero creo una nueva columna 'continente' en mi data frame
datos_por_continente <- datos_ready
datos_por_continente$Continent <- countrycode(datos_por_continente$Country, origin = "Country.Name", destination = "Continent")
datos_por_continente$Continent <- countrycode(datos_por_continente$Country, origin = "country.name", destination = "continent")
# Como no todos los nombres de paises estan en un formato reconocible por la libreria countrycode, voy a traducirlos
# usando ChatGPT. Para eso necesito copiar la lista de países a mi portapapeles usando la funcion writeClipboard.
utils::writeClipboard(datos_ready$Country.Name)
install.packages("clipr")
library(clipr)
# Como no todos los nombres de paises estan en un formato reconocible por la libreria countrycode, voy a traducirlos
# usando ChatGPT. Para eso necesito copiar la lista de países a mi portapapeles usando la funcion writeClipboard del paquete clipr.
clipr::write_clip(datos_ready$Country.Name)
m
# Copie y pegue esta lista en ChatGPT para que corrija aquellos que no son compatibles con la librería countrycode.
# Le pedi que me genere un CSV con esa lista actualizada. Ahora cargo ese CSV a R.
nombres_paises_actualizados <- read.csv("lista-compatible-nombre-paises.csv", stringsAsFactors = FALSE)
# Copie y pegue esta lista en ChatGPT para que corrija aquellos que no son compatibles con la librería countrycode.
# Le pedi que me genere un CSV con esa lista actualizada. Ahora cargo ese CSV a R.
nombres_paises_actualizados <- read.csv("lista-compatible-nombre-paises.csv", stringsAsFactors = FALSE)
# Si el número de filas corresponde con el data set original, los actualizo.
datos_newnames <- datos_ready
if (nrow(nombres_paises_actualizados) == nrow(datos_newnames)) {
# Update the row names of the original dataset using the new country names
rownames(datos_newnames) <- nombres_paises_actualizados[, 1]
} else {
cat("El número de filas no se corresponde entre ambas listas.")
}
install.packages("ggplot2")
install.packages("reshape2")
install.packages("countrycode")
install.packages("clipr")
library(ggplot2)
library(reshape2)
library(countrycode)
library(clipr)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
